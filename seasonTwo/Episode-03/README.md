# Episode-03 | Creating our Express Server

- In this episode, you’ll build the foundation of your NodeJS project by creating an Express server.
- You’ll learn how to set up the server environment, configure basic routes, and understand how Express handles HTTP requests.
- This video covers everything you need to know to get your server up and running efficiently.
- will be writing code in `/devTinder` folder - backend

## Initialize the project

```bash
abhis@Tinku MINGW64 ~/Desktop/backend/namaste-node-js/devTinder (main)
$ npm init
This utility will walk you through creating a package.json file.
It only covers the most common items, and tries to guess sensible defaults.

See `npm help init` for definitive documentation on these fields
and exactly what they do.

Use `npm install <pkg>` afterwards to install a package and
save it as a dependency in the package.json file.

Press ^C at any time to quit.
package name: (devtinder)
version: (1.0.0)
description: tinder for devs
entry point: (index.js)
test command:
git repository:
keywords: nodejs, javascript
author: Abhishek
license: (ISC)
type: (commonjs)
About to write to C:\Users\abhis\Desktop\backend\namaste-node-js\devTinder\package.json:

{
  "name": "devtinder",
  "version": "1.0.0",
  "description": "tinder for devs",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "nodejs",
    "javascript"
  ],
  "author": "Abhishek",
  "license": "ISC",
  "type": "commonjs"
}


Is this OK? (yes)
```

- created a package.json file in /devTinder folder with above info.
- create a `src` folder & inside it create `app.js` file - which is the entry/starting point of your application. Here we will initialize our app & write the node.js code
- we will use expressjs to create our server and to use it we need to install it `npm i express` - we get `node_modules` and `package-lock.json` files
  - All the code of express js went into node_modules folder. Which is the exact file we can see on npm.
  - difference between package.json and package-lock.json -> Be curios and know the importance of project files and structures - knowing nitty gritty details helps.

```md
`package.json` and `package-lock.json` both manage dependencies in a Node.js project, but they serve different purposes.

1. package.json (The Manifest)
   This file is the heart of your project. It lists the packages your project needs, but it usually defines a version range rather than an exact version.

- purpose: Defines what packages are required.
- Version Control: Uses semantic versioning rules (like ^ or ~).
- Example: "express": "^4.18.2" means "install the latest version that is compatible with 4.18.2" (so it might install 4.19.0 if available).
- Contents: Project metadata (name, scripts, author) + explicit dependencies.

2. package-lock.json (The Snapshot)
   This file is automatically generated when you modify node_modules or package.json. It locks down the exact versions of every package (and every sub-dependency) that was actually installed.

- Purpose: Ensures consistency. It guarantees that everyone working on the project has the exact same dependency tree.
- Version Control: Records the exact version url, and integrity hash.
- Example: It will specify exactly "version": "4.18.2" and where it was downloaded from.
- Contents: A massive, detailed tree of every single package installed in node_modules.

Key Difference Example
If you have "pkg": "^1.0.0" in package.json:

- Developer A runs npm install today. npm installs version 1.0.0. The lock file records 1.0.0.
- A week later, pkg releases version 1.1.0.
- Developer B runs npm install.
  - Without package-lock.json: npm looks at ^1.0.0, sees 1.1.0 is available and compatible, and installs 1.1.0. Now Dev A and Dev B have different versions, which might cause "works on my machine" bugs.
  - With package-lock.json: npm ignores the newer version and installs exactly 1.0.0 as specified in the lock file, keeping everyone in sync.
```

## DevTinder Project - other dev Notes

## Overview

DevTinder is a MERN (MongoDB, Express, React, Node.js) application designed to help developers connect and collaborate. The project uses a microservices architecture, which divides the application into two main services:

1. **Frontend**: Handles the user interface and client-side logic.
2. **Backend**: Manages server-side logic, APIs, and interactions with the database.

## DevTinder Backend

### Repository Setup

- Created a new repository for the backend service: [DevTinder Backend GitHub Repository](https://github.com/akshadjaiswal/devTinder-backend)
- Initialized the repository using `npm init`, which generated a `package.json` file for managing project dependencies and configurations.

### Learning Journey

#### 1. What is Express Framework?

- **Express** is a minimal, flexible, and robust web application framework for Node.js that simplifies server-side development.
- Explored the official website to understand its purpose and features: [Express.js Official Website](https://expressjs.com)

#### 2. Installing Express

- Installed Express in the project using npm:
  ```bash
  npm install express
  ```
- This added the Express framework to the package.json file under dependencies and created the node_modules folder to store the installed packages.

## 3. Understanding Key Files and Folders in a Node.js Project

When working on a Node.js project, several important files and folders are created to manage dependencies, configurations, and project structure. Here’s a breakdown of these key components:

## 1. `node_modules`

- **Description**:
  - The `node_modules` folder contains all the installed npm packages and their dependencies.
  - It is automatically generated when packages are installed using npm.
- **Purpose**:
  - Stores all the libraries and dependencies required by the project.
  - Can be large because it includes every package and sub-dependency specified in the project.
- **Note**:
  - You typically don’t need to manually edit this folder.
  - If deleted, it can be recreated by running `npm install`.

## 2. `package.json`

- **Description**:
  - The `package.json` file acts as the manifest file for a Node.js project, containing metadata such as project name, version, description, author, and dependencies.
- **Key Fields**:
  - `"name"`: The name of the project.
  - `"version"`: The current version of the project.
  - `"description"`: A brief description of the project.
  - `"dependencies"`: Lists npm packages required for the project.
  - `"devDependencies"`: Lists packages needed for development but not in production.
  - `"scripts"`: Defines custom npm commands for running tasks (e.g., `"start": "node app.js"`).
- **Common Commands**:
  - `npm init`: Creates a new `package.json` file.
  - `npm install <package>`: Adds a package to the project’s dependencies.
  - `npm install <package> --save-dev`: Adds a package to `devDependencies`.

## 3. `package-lock.json`

- **Description**:
  - The `package-lock.json` file is automatically generated when npm modifies the `node_modules` tree or `package.json`.
  - Ensures consistent installation of dependencies by locking the versions.
- **Purpose**:
  - Prevents issues caused by updates to dependencies or sub-dependencies.
  - Provides a detailed description of the dependency tree and specific versions installed.

## 4. Other Common Files

- **`.gitignore`**:
  - Specifies files and directories that should be ignored by Git. Commonly used to exclude `node_modules` and other generated files.
- **`README.md`**:
  - A markdown file that serves as documentation for the project, typically including instructions for installation, usage, and contribution.

## Understanding Versioning Symbols (^ vs ~)

These symbols determine how aggressive `npm` (or `yarn`) should be when updating your dependencies. They correspond to **Semantic Versioning** (Major.Minor.Patch).

### 1. Caret `^` (Most Common)

The caret updates to the latest version that is **backwards-compatible**. It allows changes that _should not_ break your code.

- **Rule**: Updates **Minor** and **Patch** versions. It freezes the **Major** version.
- **Example**: `"express": "^5.2.1"`
  - ✅ Allows: `5.2.2` (Patch fix), `5.3.0` (New feature, backward compatible).
  - ❌ Blocks: `6.0.0` (Major version with breaking changes).

> **Why it's the default**: It strikes a balance between getting new features/fixes and avoiding code-breaking updates.

### 2. Tilde `~` (Conservative)

The tilde is more strict. It only allows updates that are **bug fixes**.

- **Rule**: Updates **Patch** version only. It freezes **Major** and **Minor** versions.
- **Example**: `"express": "~5.2.1"`
  - ✅ Allows: `5.2.2`, `5.2.9`.
  - ❌ Blocks: `5.3.0` (New feature), `6.0.0` (Breaking change).

### Summary Table

| Symbol     | Meaning         | Example for `1.2.3` | Allow Update To?            |
| :--------- | :-------------- | :------------------ | :-------------------------- |
| **`^`**    | **Compatible**  | `^1.2.3`            | `1.9.9` (Yes), `2.0.0` (No) |
| **`~`**    | **Approximate** | `~1.2.3`            | `1.2.9` (Yes), `1.3.0` (No) |
| **(None)** | **Exact**       | `1.2.3`             | Only `1.2.3`                |

## Understanding npm Scripts (`start` & `dev`)

npm scripts are commands defined in `package.json` under the `"scripts"` field. They provide convenient shortcuts to run specific Node.js commands without typing the full path.

### What are `start` and `dev` Scripts?

In the `package.json`, we have defined:

```json
"scripts": {
    "start": "node src/app.js",
    "dev": "nodemon src/app.js"
}
```

### Running the Scripts

Instead of typing the full command, you can run:

```bash
npm start    # runs: node src/app.js
npm run dev  # runs: nodemon src/app.js
```

### 1. `start` Script

- **Purpose**: Used to start the application in production or normal mode.
- **Command**: `npm start`
- **What it does**: Directly runs the Node.js application using `node src/app.js`.
- **Use case**: This is the standard script for running your application in a production environment.
- **Note**: `npm start` is special—you don't need the `run` keyword; `npm start` works directly.

### 2. `dev` Script

- **Purpose**: Used during development with automatic restart on file changes.
- **Command**: `npm run dev`
- **What it does**: Runs the application using `nodemon`, which watches for file changes and automatically restarts the server.
- **Use case**: This is ideal for development because you don't need to manually restart the server every time you make changes.
- **Installation**: Requires `nodemon` to be installed as a dependency: `npm install nodemon`

### Why These Scripts Matter?

1. **Convenience**: Shorter, easier-to-remember commands.
2. **Consistency**: Everyone on the team runs the same command, avoiding inconsistencies.
3. **Automation**: You can define complex commands with multiple steps in a single script.
4. **Production vs. Development**: Different scripts for different environments.
5. **Documentation**: The scripts serve as documentation for how to run the project.

### `nodemon` - Auto-Restart Tool

`nodemon` is a utility that monitors your files for changes and automatically restarts your Node.js application. This saves development time because you don't have to manually stop and restart the server after each code change.

- **Install**: `npm install nodemon` or `npm install nodemon --save-dev` (for development only)
- **Without nodemon**: You'd have to manually stop (Ctrl+C) and restart the server after each change.
- **With nodemon**: Changes are detected instantly, and the server restarts automatically.

## server

Created the basic server using Express

```
const express = require("express")
const app = express();
const port = 3000;

app.use("/test", (req, res) => {
    res.send("Server started ")
})

app.use("/main", (req, res) => {
    res.send("another route")
})

app.listen(port, () => {
    console.log("Server started running on port " + port)
})

```

## Understanding the `-g` Flag in `npm install`

## What is `-g` in `npm install`?

The `-g` flag stands for "global" and is used with the `npm install` command to install packages globally on your system, rather than locally within a specific project.

## Local vs. Global Installation

### Local Installation (Default)

- When you run `npm install <package>`, the package is installed locally in the `node_modules` directory of the current project.
- The package is only accessible within that project and is added to the project's `package.json` dependencies.

### Global Installation (`-g` Flag)

- When you run `npm install -g <package>`, the package is installed globally on your system.
- This makes the package accessible from the command line in any directory.
- Global installation is typically used for packages that provide command-line tools (e.g., `npm`, `nodemon`, `eslint`).

## Example Usage

To install a package globally:

```bash
npm install -g <package>
npm install -g nodemon
```
